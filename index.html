<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>DizzyGlitch</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui,-apple-system,sans-serif}
  #stage{position:fixed;inset:0}
  video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;background:#000}
  .fade-in{animation:fi .65s ease-out forwards;opacity:0}
  .fade-out{animation:fo .65s ease-in forwards;opacity:1}
  @keyframes fi{to{opacity:1}} @keyframes fo{to{opacity:0}}

  #overlay{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.86);color:#fff;z-index:10;padding:24px}
  #card{max-width:640px;text-align:center}
  h1{margin:0 0 10px;font-size:22px}
  p{margin:0 0 14px;opacity:.9;line-height:1.35}
  input{
    width:min(520px, 92vw);
    padding:12px 14px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.18);
    background:rgba(0,0,0,.35);
    color:#fff;
    font-size:16px;
    outline:none;
  }
  button{background:#fff;color:#000;border:0;border-radius:12px;padding:12px 14px;font-weight:700;margin-top:10px}
  #small{margin-top:10px;font-size:12px;opacity:.75}

  #hud{position:fixed;left:12px;right:12px;bottom:12px;display:flex;gap:10px;justify-content:space-between;z-index:5;pointer-events:none}
  .pill{padding:8px 10px;border-radius:999px;background:rgba(0,0,0,.55);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);
        color:rgba(255,255,255,.82);font-size:12px;max-width:70%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
</style>
</head>
<body>
<div id="stage"></div>

<div id="overlay">
  <div id="card">
    <h1>DizzyGlitch</h1>
    <p>
      Tap Start. It will immediately play a known-good demo video, then load Internet Archive channels in the background and start flipping.
    </p>
    <input id="q" placeholder='Try: "night", "noir", "comedy", "bus", "short"' autocomplete="off" />
    <button id="start">Tap to Start</button>
    <div id="small">If anything breaks, the bottom-left status will show the error.</div>
  </div>
</div>

<div id="hud" aria-hidden="true">
  <div class="pill" id="status">ready</div>
  <div class="pill" id="now">—</div>
</div>

<script>
  const stage = document.getElementById("stage");
  const statusEl = document.getElementById("status");
  const nowEl = document.getElementById("now");
  const qEl = document.getElementById("q");

  // Show JS errors on-screen (so we can fix fast)
  window.onerror = (msg, src, line, col) => {
    statusEl.textContent = `JS error: ${String(msg).slice(0, 80)} @${line}:${col}`;
  };
  window.onunhandledrejection = (e) => {
    statusEl.textContent = `Promise error: ${String(e.reason).slice(0, 90)}`;
  };

  // Always-works fallback (this should ALWAYS show video immediately)
  const FALLBACK = {
    title: "flower (demo)",
    url: "https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4",
    tags: ["demo"]
  };

  // IA channels (we resolve filenames via metadata)
  const CHANNELS = [
    { id: "Oh_Mr.Porter_1937", title: "Oh, Mr. Porter! (1937)", tags: ["comedy","train","night","british"] },
    { id: "He_Walked_by_Night_1948", title: "He Walked by Night (1948)", tags: ["noir","night","police","dark","city"] },
    { id: "Friday_the_Thirteenth_1933", title: "Friday the Thirteenth (1933)", tags: ["bus","british","drama","dark"] },
    { id: "RomanceSentimentale", title: "Romance Sentimentale (1930)", tags: ["short","avant","experimental","surreal"] },
  ];

  let current = null;
  let running = false;
  let playable = []; // resolved {title,url,tags}

  const randInt = (min,max)=>Math.floor(Math.random()*(max-min+1))+min;
  const randFloat = (min,max)=>Math.random()*(max-min)+min;

  function tokenize(s){
    return (s||"")
      .toLowerCase()
      .replace(/[^a-z0-9\s']/g," ")
      .split(/\s+/)
      .filter(Boolean)
      .slice(0, 18);
  }

  function score(item, tokens){
    if (!tokens.length) return 1;
    const hay = (item.tags.join(" ") + " " + item.title).toLowerCase();
    let hits = 0;
    for (const t of tokens){
      if (t.length < 3) continue;
      if (hay.includes(t)) hits++;
    }
    return hits;
  }

  function pickClip(tokens){
    const base = playable.length ? playable : [FALLBACK];
    const scored = base
      .map(x => ({x, s: score(x, tokens)}))
      .filter(o => tokens.length ? o.s > 0 : true);

    const pool = scored.length ? scored : base.map(x => ({x, s: 1}));
    const total = pool.reduce((a,b)=>a + (b.s || 1), 0);

    let r = Math.random() * total;
    for (const o of pool){
      r -= (o.s || 1);
      if (r <= 0) return o.x;
    }
    return pool[pool.length - 1].x;
  }

  function makeVideo(src){
    const v = document.createElement("video");
    v.src = src;
    v.muted = true;       // iOS autoplay requirement
    v.playsInline = true; // stay inline
    v.autoplay = true;
    v.preload = "auto";
    return v;
  }

  async function swapTo(item){
    const v = makeVideo(item.url);

    // If a clip errors, drop it from the pool and keep going
    v.onerror = () => {
      statusEl.textContent = "video error → skipping";
      playable = playable.filter(p => p.url !== item.url);
      // keep looping; next tick will pick something else
    };

    v.addEventListener("loadedmetadata", () => {
      const dur = Number.isFinite(v.duration) ? v.duration : 0;
      if (dur > 4){
        try { v.currentTime = randFloat(0, Math.max(0, dur - 2)); } catch {}
      }
    }, {once:true});

    if (!current){
      stage.appendChild(v);
      current = v;
    } else {
      v.classList.add("fade-in");
      current.classList.add("fade-out");
      stage.appendChild(v);
      const old = current;
      current = v;
      setTimeout(()=>{ try{old.pause()}catch{} old.remove(); }, 750);
    }

    nowEl.textContent = item.title;
    try { await v.play(); } catch { /* ok; iOS can be picky */ }
  }

  function startMicroCuts(){
    const tick = () => {
      if (!running || !current) return;
      const dur = Number.isFinite(current.duration) ? current.duration : 0;
      if (dur > 4){
        try { current.currentTime = randFloat(0, Math.max(0, dur - 1.5)); } catch {}
      }
      setTimeout(tick, randInt(250, 1200));
    };
    setTimeout(tick, randInt(250, 1200));
  }

  async function resolveIAItem(ch){
    // metadata endpoint
    const metaUrl = `https://archive.org/metadata/${encodeURIComponent(ch.id)}`;
    const res = await fetch(metaUrl, { headers: { "Accept": "application/json" }});
    if (!res.ok) throw new Error(`metadata ${ch.id} HTTP ${res.status}`);

    const data = await res.json();
    const files = Array.isArray(data.files) ? data.files : [];

    // Prefer "512KB MPEG4" derivative (small, iPhone-friendly)
    let f = files.find(x => String(x.format||"").toLowerCase().includes("512kb mpeg4"));
    if (!f) f = files.find(x => String(x.name||"").toLowerCase().includes("512kb") && String(x.name||"").toLowerCase().endsWith(".mp4"));
    if (!f) f = files.find(x => String(x.format||"").toLowerCase().includes("mpeg4") && String(x.name||"").toLowerCase().endsWith(".mp4"));
    if (!f || !f.name) throw new Error(`no mp4 for ${ch.id}`);

    // IMPORTANT: Do NOT encode the whole filename with encodeURIComponent twice logic;
    // we only encode each path segment once.
    const fileName = encodeURIComponent(f.name);
    const itemId = encodeURIComponent(ch.id);
    const url = `https://archive.org/download/${itemId}/${fileName}`;
    return { title: ch.title, url, tags: ch.tags };
  }

  async function loadChannelsInBackground(){
    statusEl.textContent = "loading IA channels…";
    const out = [];

    // Resolve sequentially (gentler on mobile + avoids rate issues)
    for (const ch of CHANNELS){
      try{
        const item = await resolveIAItem(ch);
        out.push(item);
        statusEl.textContent = `loading IA channels… (${out.length})`;
      }catch(e){
        // show last failure briefly but continue
        statusEl.textContent = `IA skip: ${String(e.message).slice(0, 40)}`;
      }
    }

    playable = out;
    statusEl.textContent = playable.length ? `IA ready (${playable.length})` : "IA failed → demo only";
  }

  async function loop(){
    if (!running) return;
    const clip = pickClip(tokenize(qEl.value));
    await swapTo(clip);
    setTimeout(loop, randInt(2500, 9000));
  }

  document.getElementById("start").onclick = async () => {
    document.getElementById("overlay").remove();
    running = true;

    // 1) IMMEDIATELY show something
    statusEl.textContent = "starting (demo)…";
    await swapTo(FALLBACK);

    // 2) begin glitch cuts
    startMicroCuts();

    // 3) start flipping right away (even if only demo at first)
    loop();

    // 4) load IA in the background; once playable[] fills, loop() will start picking those
    loadChannelsInBackground();
  };
</script>
</body>
</html>
